To automate database operations such as hitting a SQL query, getting the result, and validating it in a Cypress automation project, you'll need to use a combination of tools since Cypress itself is not designed for direct database interactions. However, you can achieve this by integrating Cypress with a Node.js package that supports SQL Server.

Steps to Automate SQL Query Execution and Validation in Cypress
1. Install Required Packages
You’ll need to install a Node.js package that can interact with SQL Server, such as mssql.

Install the mssql package by running:
bash
npm install mssql --save-dev

2. Configure SQL Server Connection
Create a separate configuration file or add the configuration within your Cypress commands file.
Example configuration
const sql = require('mssql');

const config = {
  user: 'your_username',
  password: 'your_password',
  server: 'your_server',
  database: 'your_database',
  options: {
    encrypt: true, // Use encryption
    trustServerCertificate: true // For self-signed certificates
  }
};

const connectToDatabase = async () => {
  try {
    let pool = await sql.connect(config);
    return pool;
  } catch (err) {
    console.error('Database connection failed: ', err);
  }
};


3. Create a Custom Command in Cypress
Add a custom Cypress command to interact with the SQL database.
In cypress/support/commands.js, add

Cypress.Commands.add('executeSQLQuery', async (query) => {
  const pool = await connectToDatabase();
  try {
    let result = await pool.request().query(query);
    return result.recordset;
  } catch (err) {
    console.error('SQL query execution failed: ', err);
  }
});


4. Write a Cypress Test to Run the SQL Query and Validate the Result
Use the custom command in your Cypress tests to execute the SQL query and validate the results.
Example tes

describe('Database Test', () => {
  it('should validate data from SQL Server', () => {
    const query = 'SELECT * FROM your_table WHERE condition';
    
    cy.executeSQLQuery(query).then((result) => {
      // Perform your validations here
      expect(result).to.have.lengthOf.at.least(1);
      expect(result[0]).to.have.property('column_name', 'expected_value');
    });
  });
});


5. Handle Database Connections Properly
Ensure that database connections are properly closed after each test to avoid memory leaks.

You can add a teardown step in your afterEach or after hooks.

afterEach(() => {
  sql.close(); // Close the connection after each test
});

Additional Tips
Environment Variables: Store sensitive information like database credentials in environment variables or a secure configuration file.
Error Handling: Implement proper error handling within your custom commands to catch and log any issues that arise during the SQL query execution.
Test Data Management: Consider setting up and tearing down test data before and after tests to ensure that your tests are consistent and repeatable.
By following these steps, you can automate the process of querying your SQL Server database and validating the results within your Cypress tests.

@@@@@@@@@@@@@@@@@@@@@@@
Scenario
Suppose you have an application where you need to validate that a record exists in the Users table of your SQL Server database after a certain action is performed in your application. You want to automate the following:

Perform an action in your application (e.g., submit a form).
Run a SQL query to verify that the data has been correctly inserted into the database.
Validate the result of the SQL query in your Cypress test.
Step-by-Step Guide
Step 1: Install Required Packages
First, you'll need to install the mssql package, which is a Node.js library for connecting to SQL Server.

npm install mssql --save-dev

Step 2: Configure SQL Server Connection
Next, create a connection configuration to your SQL Server database. You can either do this in a separate file or within your Cypress custom commands file.

Let’s create a db.js file inside the cypress/support folder:
// cypress/support/db.js
const sql = require('mssql');

const config = {
  user: 'your_username',
  password: 'your_password',
  server: 'your_server', // e.g., 'localhost'
  database: 'your_database',
  options: {
    encrypt: true, // Use encryption for data transfer if required
    trustServerCertificate: true // Only set to true for local development
  }
};

const connectToDatabase = async () => {
  try {
    let pool = await sql.connect(config);
    return pool;
  } catch (err) {
    console.error('Database connection failed: ', err);
    throw err;
  }
};

module.exports = { connectToDatabase };

Step 3: Create a Custom Command in Cypress
Now, create a custom Cypress command to execute SQL queries. This will allow you to easily run SQL queries within your Cypress tests.

Add the following code to cypress/support/commands.js:
// cypress/support/commands.js
const { connectToDatabase } = require('./db');

Cypress.Commands.add('executeSQLQuery', (query) => {
  return connectToDatabase().then(pool => {
    return pool.request().query(query);
  });
});

Step 4: Write a Cypress Test to Run the SQL Query and Validate the Result
With the custom command in place, you can now write a Cypress test to perform an action in your application, execute the SQL query, and validate the result.

Let’s assume that submitting a form in your application should insert a new user record into the Users table.

Here’s how the test might look:
describe('Database Validation Test', () => {
  it('should insert a new user into the database and validate it', () => {
    // Step 1: Perform the action in your application
    cy.visit('/register'); // Assume this is the URL of the registration page
    cy.get('#username').type('testuser'); // Enter the username
    cy.get('#password').type('password123'); // Enter the password
    cy.get('#submit-button').click(); // Submit the form

    // Step 2: Run the SQL query to check if the user was added to the database
    const query = "SELECT * FROM Users WHERE username = 'testuser'";
    
    cy.executeSQLQuery(query).then((result) => {
      // Step 3: Validate the result
      expect(result.recordset).to.have.lengthOf(1); // Ensure one record is returned
      expect(result.recordset[0]).to.have.property('username', 'testuser'); // Validate the username
    });
  });
});

Step 5: Handle Database Connections Properly
After executing your SQL query, it’s important to ensure that the database connection is properly closed to avoid memory leaks.

You can handle this by adding an afterEach or after hook to close the connection:
// cypress/support/commands.js
const sql = require('mssql');

// Close the database connection after each test
afterEach(() => {
  sql.close();
});

Example in Action
Let’s summarize the workflow:

Perform the Action: Cypress navigates to the registration page, enters a username and password, and submits the form.
Execute SQL Query: After the form submission, Cypress runs a SQL query to check if the new user was added to the Users table.
Validate the Result: Cypress asserts that the query result contains the expected user data.
Environment Variable Handling (Optional)
If your database credentials and other sensitive information should not be hard-coded, consider using environment variables:

Store credentials in environment variables (e.g., .env file) and use a package like dotenv to load them:

npm install dotenv --save-dev

Modify db.js to use environment variables:
require('dotenv').config();

const config = {
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  server: process.env.DB_SERVER,
  database: process.env.DB_DATABASE,
  options: {
    encrypt: true,
    trustServerCertificate: true
  }
};

Add .env to .gitignore to ensure it’s not committed to version control.

Conclusion
By following these steps, you can integrate SQL Server database operations within your Cypress tests, enabling you to automate the validation of data directly within the database as part of your end-to-end testing process. 
This approach ensures that your tests are more comprehensive and cover not just the UI, but also the underlying data integrity.



@@@@@@@@@@@@@@@@@@@@@@@@
To automate the scenario where you log into an application, receive a link via Outlook webmail, find this link in the inbox, and open it in a browser using Cypress, you can follow these steps.

Step 1: Install Required Dependencies
You'll need to install a few dependencies to interact with Outlook webmail and handle emails.

Cypress Commands: Install Cypress if you haven’t already.
Node.js IMAP Client: Use the imap-simple package to interact with Outlook webmail via IMAP.
Install the imap-simple and mailparser packages:

bash
npm install imap-simple mailparser --save-dev

Step 2: Set Up the IMAP Connection
Create a new file, say cypress/support/email.js, where you’ll configure the IMAP connection and write the logic to find the email with the link.
const imaps = require('imap-simple');
const { simpleParser } = require('mailparser');

const config = {
  imap: {
    user: process.env.OUTLOOK_EMAIL, // Your Outlook email
    password: process.env.OUTLOOK_PASSWORD, // Your Outlook password
    host: 'outlook.office365.com',
    port: 993,
    tls: true,
    authTimeout: 3000
  }
};

const searchCriteria = ['UNSEEN'];
const fetchOptions = {
  bodies: ['HEADER', 'TEXT'],
  markSeen: true
};

function findLinkInEmail(text) {
  const linkRegex = /https?:\/\/[^\s]+/g;
  const matches = text.match(linkRegex);
  return matches ? matches[0] : null;
}

Cypress.Commands.add('getEmailLink', () => {
  return imaps.connect({ imap: config.imap }).then(connection => {
    return connection.openBox('INBOX').then(() => {
      return connection.search(searchCriteria, fetchOptions).then(messages => {
        let promises = messages.map(item => {
          let all = item.parts.filter(part => part.which === 'TEXT');
          let html = all[0].body;

          return simpleParser(html).then(parsed => {
            return findLinkInEmail(parsed.text || parsed.html);
          });
        });

        return Promise.all(promises).then(links => {
          let validLinks = links.filter(link => link !== null);
          return validLinks.length ? validLinks[0] : null;
        });
      });
    });
  });
});

Step 3: Write the Cypress Test
Now that you’ve set up the IMAP connection and added a custom command to find the email link, you can write the Cypress test to automate the scenario:

javascript
describe('Login and Verify Email Link', () => {
  it('should login, find the email, and open the link', () => {
    // Step 1: Log in to your application
    cy.visit('/login');
    cy.get('#username').type('your-username');
    cy.get('#password').type('your-password');
    cy.get('#login-button').click();

    // Step 2: Get the link from the Outlook webmail inbox
    cy.getEmailLink().then(link => {
      expect(link).to.not.be.null;
      cy.visit(link); // Open the link in the browser
    });
  });
});

Step 4: Configure Environment Variables
Store your Outlook credentials in environment variables to avoid hardcoding sensitive information.

Create a .env file in your project root:

env
OUTLOOK_EMAIL=your-email@outlook.com
OUTLOOK_PASSWORD=your-password

Load these environment variables in Cypress by modifying your cypress.json or using the dotenv package.

Step 5: Run the Test
Run your Cypress test as usual. The script will:

Log into your application.
Connect to your Outlook webmail inbox via IMAP.
Search for the latest unseen email.
Extract the first link found in the email body.
Open the extracted link in the browser.
Additional Considerations
Error Handling: Add proper error handling if no emails are found or if the link extraction fails.
Email Delays: Consider adding a retry mechanism or waiting logic if the email might take some time to arrive.
Environment Setup: Ensure your Outlook account is configured to allow IMAP access and that any security settings are configured to work with your test.
This setup will allow you to automate the process of logging in, retrieving an email, extracting a link, and navigating to that link in your browser.

@@@@@@@@@@@@@@@@@
Certainly! Let’s go through a detailed example to help you automate the scenario where, after logging into an application, you receive a link via Outlook webmail, find this link in the inbox, and open it in a browser using Cypress.

Scenario
Login to an Application: Perform a login operation on your application.
Receive an Email with a Link: After logging in, an email containing a verification or action link is sent to your Outlook inbox.
Retrieve the Link from the Email: Access your Outlook inbox, find the email, and extract the link.
Open the Link in the Browser: Once you have the link, open it in the browser to continue the test.
Step 1: Set Up Your Project
Before diving into the script, make sure you have the following installed:

Cypress: For end-to-end testing.
Node.js IMAP Client: For interacting with Outlook webmail via IMAP.
Install these packages:

npm install cypress --save-dev
npm install imap-simple mailparser --save-dev

Step 2: Set Up IMAP Connection in Cypress
To interact with your Outlook inbox, you’ll need to configure an IMAP connection. Let’s create a utility to manage this connection.

Create cypress/support/email.js
This file will contain the logic for connecting to the Outlook server and retrieving emails.

javascript
// cypress/support/email.js
const imaps = require('imap-simple');
const { simpleParser } = require('mailparser');

const config = {
  imap: {
    user: process.env.OUTLOOK_EMAIL, // Your Outlook email
    password: process.env.OUTLOOK_PASSWORD, // Your Outlook password
    host: 'outlook.office365.com',
    port: 993,
    tls: true,
    authTimeout: 3000
  }
};

const searchCriteria = ['UNSEEN']; // Fetch only unseen (new) emails
const fetchOptions = {
  bodies: ['HEADER', 'TEXT'],
  markSeen: true // Mark emails as read after fetching
};

function findLinkInEmail(text) {
  const linkRegex = /https?:\/\/[^\s]+/g;
  const matches = text.match(linkRegex);
  return matches ? matches[0] : null; // Return the first link found
}

Cypress.Commands.add('getEmailLink', () => {
  return imaps.connect({ imap: config.imap }).then(connection => {
    return connection.openBox('INBOX').then(() => {
      return connection.search(searchCriteria, fetchOptions).then(messages => {
        let promises = messages.map(item => {
          let all = item.parts.filter(part => part.which === 'TEXT');
          let html = all[0].body;

          return simpleParser(html).then(parsed => {
            return findLinkInEmail(parsed.text || parsed.html);
          });
        });

        return Promise.all(promises).then(links => {
          let validLinks = links.filter(link => link !== null);
          return validLinks.length ? validLinks[0] : null;
        });
      });
    });
  });
});

Step 3: Write the Cypress Test
Now that you’ve set up the IMAP connection and custom command to fetch the email link, you can write your Cypress test.

Create a Test File
Let’s say you have a test file named emailLinkTest.cy.js under cypress/e2e.
// cypress/e2e/emailLinkTest.cy.js
describe('Login and Verify Email Link', () => {
  it('should log in, find the email, and open the link', () => {
    // Step 1: Log in to your application
    cy.visit('https://your-application-url.com/login');
    cy.get('#username').type('your-username');
    cy.get('#password').type('your-password');
    cy.get('#login-button').click();

    // Step 2: Get the link from the Outlook webmail inbox
    cy.getEmailLink().then(link => {
      // Validate that the link is not null
      expect(link).to.not.be.null;
      cy.log('Email link found: ' + link);

      // Step 3: Open the link in the browser
      cy.visit(link);
    });
  });
});


Step 4: Set Up Environment Variables
To keep your Outlook credentials secure, store them in environment variables.

Create a .env file in the root of your project:

env
OUTLOOK_EMAIL=your-email@outlook.com
OUTLOOK_PASSWORD=your-password

Load Environment Variables: Make sure these are loaded in your Cypress setup. You can use the dotenv package:
npm install dotenv --save-dev

Load the .env file in cypress/plugins/index.js:
require('dotenv').config();

Step 5: Running the Test
Now that everything is set up, you can run your Cypress test as usual:
npx cypress open

Select your test (emailLinkTest.cy.js) and run it.

Step 6: Explanation of How It Works
Login to the Application: The test starts by visiting the login page of your application, entering the username and password, and submitting the form.

Fetch the Email: After the login action, the cy.getEmailLink() command connects to your Outlook inbox using IMAP, searches for the latest unread email, parses the email content, and extracts the first link found.

Validate and Open the Link: Once the link is found, the test validates that the link is not null and then visits that link in the browser.

Troubleshooting
Email Delays: Sometimes, emails may take a while to arrive. If this is the case, you can add a wait or retry mechanism before fetching the email.
No Link Found: Ensure that the email content is being parsed correctly and that the link pattern matches what you expect.
This example should give you a complete guide to automating the process of retrieving an email from Outlook and following a link within it using Cypress.

@@@@@@@@ DB Assertions:::

Cypress allows a variety of assertions for validating database query results. These assertions are used to check different conditions, such as equality, length, type, and structure of the returned data from your database query. Below are some commonly used assertions that you can implement for database validation.

1. Equality Assertions
Used to check whether a value is equal to an expected value. This is useful for validating specific data points in a row or a particular query result.

cy.task('queryDatabase', 'SELECT TOP 1 * FROM users').then((result) => {
  const firstRow = result[0];

  // Check if the 'name' column equals "John Doe"
  expect(firstRow.name).to.equal('John Doe');

  // Check if the 'id' column equals 1 (strict equality for numbers)
  expect(firstRow.id).to.equal(1);
});


Deep Equality Assertions
For comparing entire objects, where all properties of the object should match the expected values.

cy.task('queryDatabase', 'SELECT TOP 1 * FROM users').then((result) => {
  const expectedUser = { id: 1, name: 'John Doe', email: 'john@example.com' };

  // Validate that the first row matches the expected object
  expect(result[0]).to.deep.equal(expectedUser);
});


 Length Assertions
Used to validate the number of rows returned by a query.

cy.task('queryDatabase', 'SELECT * FROM users WHERE active = 1').then((result) => {
  // Check if there are exactly 5 active users
  expect(result).to.have.length(5);
});


Existence/Non-Existence Assertions
Used to check whether specific data exists or doesn't exist in the result set.

cy.task('queryDatabase', 'SELECT * FROM users WHERE email = "nonexistent@example.com"').then((result) => {
  // Validate that no user with this email exists
  expect(result).to.be.empty;
});


cy.task('queryDatabase', 'SELECT * FROM users WHERE email = "john@example.com"').then((result) => {
  // Validate that the user exists
  expect(result).to.not.be.empty;
});


Type Assertions
Used to verify the data type of a particular value returned from the query.

cy.task('queryDatabase', 'SELECT TOP 1 * FROM users').then((result) => {
  const firstRow = result[0];

  // Check if the 'id' column is a number
  expect(firstRow.id).to.be.a('number');

  // Check if the 'name' column is a string
  expect(firstRow.name).to.be.a('string');
});


Greater Than / Less Than Assertions
Useful for comparing numerical or date-based values.

cy.task('queryDatabase', 'SELECT TOP 1 * FROM users ORDER BY created_at DESC').then((result) => {
  const firstRow = result[0];

  // Validate that the user ID is greater than 0
  expect(firstRow.id).to.be.greaterThan(0);

  // Validate that the user was created after a certain date
  const createdDate = new Date(firstRow.created_at);
  expect(createdDate.getFullYear()).to.be.greaterThan(2020);
});


7. Contain/Include Assertions
Used for checking if a result includes specific values, often used with strings or arrays.

cy.task('queryDatabase', 'SELECT TOP 1 * FROM users').then((result) => {
  const firstRow = result[0];

  // Check if the 'email' contains '@example.com'
  expect(firstRow.email).to.include('@example.com');

  // Check if the 'roles' array includes 'admin'
  expect(firstRow.roles).to.include('admin');
});

8. Array-Specific Assertions
Used for validating that returned data is an array and contains the expected values.

cy.task('queryDatabase', 'SELECT roles FROM users WHERE id = 1').then((result) => {
  const rolesArray = result[0].roles; // Assuming roles is an array

  // Check if roles is an array
  expect(rolesArray).to.be.an('array');

  // Check if the roles array includes 'admin'
  expect(rolesArray).to.include('admin');
});

9. Property Assertions
Used to verify the presence or absence of certain properties (columns) in the result.

cy.task('queryDatabase', 'SELECT TOP 1 * FROM users').then((result) => {
  const firstRow = result[0];

  // Check if the row has a 'name' property
  expect(firstRow).to.have.property('name');

  // Check if the row has a 'created_at' property
  expect(firstRow).to.have.property('created_at');

  // Validate that 'id' exists and is equal to 1
  expect(firstRow).to.have.property('id', 1);
});


10. Negations
Assertions can also be negated to check for the opposite condition.

cy.task('queryDatabase', 'SELECT * FROM users WHERE id = 1').then((result) => {
  const firstRow = result[0];

  // Ensure that 'name' is not equal to "Jane Doe"
  expect(firstRow.name).to.not.equal('Jane Doe');

  // Ensure the 'roles' array does not include 'guest'
  expect(firstRow.roles).to.not.include('guest');
});


11. Date Assertions
Used to compare date fields.
cy.task('queryDatabase', 'SELECT TOP 1 * FROM users ORDER BY created_at DESC').then((result) => {
  const createdDate = new Date(result[0].created_at);

  // Check if the created date is a valid date
  expect(createdDate).to.be.a('date');

  // Ensure the user was created after January 1, 2022
  expect(createdDate).to.be.greaterThan(new Date('2022-01-01'));
});

Example Scenario
Let’s say you have a table called users with columns id, name, email, and created_at. You want to:

Validate the data type of certain columns.
Ensure that a user exists.
Check the number of users.
Ensure the email format is correct.

cy.task('queryDatabase', 'SELECT * FROM users WHERE id = 1').then((result) => {
  const firstRow = result[0];

  // Check that a user with id 1 exists
  expect(result).to.have.length.greaterThan(0);

  // Validate that the 'id' is a number
  expect(firstRow.id).to.be.a('number');

  // Ensure the 'name' is a string
  expect(firstRow.name).to.be.a('string');

  // Validate that the email contains '@example.com'
  expect(firstRow.email).to.include('@example.com');

  // Ensure the 'created_at' is a valid date
  expect(new Date(firstRow.created_at)).to.be.a('date');
});


Summary of Assertions
Equality: .to.equal()
Deep Equality: .to.deep.equal()
Length: .to.have.length(), .to.have.length.greaterThan()
Existence: .to.not.be.empty, .to.be.empty
Type: .to.be.a()
Greater Than/Less Than: .to.be.greaterThan(), .to.be.lessThan()
Contain/Include: .to.include()
Array: .to.be.an('array'), .to.include()
Property: .to.have.property()
Negation: .to.not.equal()
Date: .to.be.a('date'), .to.be.greaterThan()
These assertions can be tailored based on the structure of your database and the specific validations you need to perform.

@@@@@@@@@@@@@@@@@@@@@@@@@

describe('Login Test with Detailed Report', () => {
  it('Login Test Steps', () => {
    cy.log('Step 1: Open browser and enter URL');
    cy.visit('https://example.com')
      .then(() => {
        cy.log('Action: URL entered successfully');
      });

    cy.log('Step 2: Enter User Name');
    cy.get('input[name="username"]').type('your-username')
      .then(() => {
        cy.log('Action: User Name entered successfully');
      });

    cy.log('Step 3: Enter Password');
    cy.get('input[name="password"]').type('your-password')
      .then(() => {
        cy.log('Action: Password entered successfully');
      });

    cy.log('Step 4: Click Submit button');
    cy.get('button[type="submit"]').click()
      .then(() => {
        cy.log('Action: User is landed on home page screen');
      });
  });
});


const { defineConfig } = require("cypress");

module.exports = defineConfig({
  reporter: "cypress-mochawesome-reporter",
  reporterOptions: {
    reportDir: "cypress/reports",
    overwrite: false,
    html: true,
    json: true,
  },
  e2e: {
    setupNodeEvents(on, config) {
      require("cypress-mochawesome-reporter/plugin")(on);
    },
  },
});

@@@@@@@@@@@@@@@@@@@@@@@
Cypress.Commands.add('logStep', (stepName, actionDescription) => {
  cy.log(`Step: ${stepName}`);
  cy.log(`Action: ${actionDescription}`);
  // Adding a fake assertion so that Mocha captures this as a "pass"
  cy.wrap(null).should('equal', null, `${stepName} - ${actionDescription} - Pass`);
});


describe('Login Test with Detailed Report', () => {

  it('Should log test steps with pass/fail status', () => {

    // Step 1: Open browser and enter URL
    cy.logStep('Open browser and enter URL', 'URL entered successfully');
    cy.visit('https://example.com');

    // Step 2: Enter User Name
    cy.logStep('Enter User Name', 'User Name entered successfully');
    cy.get('input[name="username"]').type('your-username');

    // Step 3: Enter Password
    cy.logStep('Enter Password', 'Password entered successfully');
    cy.get('input[name="password"]').type('your-password');

    // Step 4: Click Submit button
    cy.logStep('Click Submit button', 'User is landed on home page screen');
    cy.get('button[type="submit"]').click();
  });

});

@@@ on task @@@
const fs = require('fs');
const path = require('path');

module.exports = {
  e2e: {
    setupNodeEvents(on, config) {
      on('task', {
        logStep({ stepName, actionDescription, status }) {
          console.log(`Step: ${stepName} | Action: ${actionDescription} | Status: ${status}`);
          return null;
        },
      });
    },
  },
  reporter: "mochawesome",
  reporterOptions: {
    reportDir: "cypress/reports",
    overwrite: false,
    html: true,
    json: true,
    reportTitle: "Detailed Test Report",
  },
};

describe('Login Test with Detailed Report', () => {

  it('Should log test steps with pass/fail status', () => {

    // Step 1: Open browser and enter URL
    cy.visit('https://example.com');
    cy.task('logStep', {
      stepName: 'Open browser and enter URL',
      actionDescription: 'URL entered successfully',
      status: 'Pass'
    });

    // Step 2: Enter User Name
    cy.get('input[name="username"]').type('your-username');
    cy.task('logStep', {
      stepName: 'Enter User Name',
      actionDescription: 'User Name entered successfully',
      status: 'Pass'
    });

    // Step 3: Enter Password
    cy.get('input[name="password"]').type('your-password');
    cy.task('logStep', {
      stepName: 'Enter Password',
      actionDescription: 'Password entered successfully',
      status: 'Pass'
    });

    // Step 4: Click Submit button
    cy.get('button[type="submit"]').click();
    cy.task('logStep', {
      stepName: 'Click Submit button',
      actionDescription: 'User is landed on home page screen',
      status: 'Pass'
    });

  });

});






